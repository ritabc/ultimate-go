<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.8 (457454)"/><meta name="altitude" content="90.33164978027344"/><meta name="author" content="Rita C Bennett-Chew"/><meta name="created" content="2019-09-23 14:42:59 +0000"/><meta name="latitude" content="35.92474802308006"/><meta name="longitude" content="-79.01528211562591"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-09-23 20:23:32 +0000"/><title>Lesson 2: Syntax</title></head><body><div><span style="font-weight: bold; font-size: 18px;">Variables</span></div><ul><li><div>access to memory is type safe</div></li><li><div>Integers: </div></li><ul><li><div>don’t used precision-based integers unless you have a specific reason to do so - depending on the architecture, integers can change size</div></li><li><div>how much memory allocated</div></li><li><div>
<span style="font-size: 14px; background-color: rgb(254, 244, 156); color: rgb(0, 0, 0); font-family: Menlo; font-stretch: normal; font-style: normal; font-variant-caps: normal; font-variant-ligatures: no-common-ligatures; font-weight: normal; line-height: normal;">go version go1.11.5 darwin/amd64</span></div></li><ul><li><div>64 bits or 8 bytes system</div></li></ul></ul><li><div>While working in Go Playground</div></li><ul><li><div> architecture is single threaded environment (can’t use it for concurrency)</div></li><li><div>amd64 p32 architecture: addresses are 32 bits here</div></li></ul><li><div>Too many ways to create variables</div></li><li><div>Cost of integrity is performance</div></li><li><div>Zero value: all memory that we allocate gets initialized at least to it’s zero value</div></li><ul><li><div>helps with past bugs (ie, js declared but not initialized?)</div></li><li><div>‘var’ keyword always gives zero value</div></li></ul><li><div>Strings</div></li><ul><li><div>2-word data value</div></li><li><div>contains two things</div></li><ol><li><div>pointer</div></li><li><div>number of bytes</div></li></ol><li><div>zero value</div></li><ol><li><div>nil</div></li><li><div>0</div></li></ol><li><div>string “hello"</div></li><ul><li><div>*  —&gt; |h|e|l|l|o|</div></li><li><div>5</div></li></ul></ul><li><div>Go has conversion, not casting </div></li><ul><li><div>What is casting? </div></li><ul><li><div>Takes memory cost as values converted from 1 type to another</div></li><li><div>helps with performance</div></li><li><div>Say we’ve allocated a 1 byte integer a, but we want it to represent a 4 byte integer </div></li><ul><li><div>a currently: |10|</div></li><li><div>post-cast: |10|   |   |   | We pretend that a is a 4 byte integer, and can write / read to those extra slots, possibly corrupting memory</div></li><li><div>In reality, it’s a little more complicated but casting must be very accurate</div></li></ul></ul><li><div>In Go, integrity is key. Conversion will happen instead</div></li><ul><li><div>Instead of expanding a, in order to make a 4 bytes, we convert it into a new value, possibly with a new variable name</div></li></ul></ul></ul><div><font style="font-size: 18px;"><span style="font-size: 18px; font-weight: bold;">Structs</span></font></div><ul><li><div>How much memory does initialization of new struct take up?</div></li><ul><li><div>For example: </div></li><ul><li><div><img src="Lesson%202%3A%20Syntax.html.resources/83DD13F9-3531-4739-AB1B-EEDEB5BCD825.png" height="93" width="215"/></div></li><li><div>flag = 1 byte, counter = 2 bytes, pi = 4 bytes</div></li><li><div>We’d think 7 bytes to create new example</div></li></ul><li><div>Not as much as sum of fields, because of alignments</div></li></ul><li><div>Alignments are to make reading &amp; writing memory as efficient as possible</div></li><li><div>Say we don’t have alignments:</div></li><ul><li><div>we need to deal with hardware boundaries: machine-word boundary</div></li><li><div>hardware is able to read and write over each of these boundaries: [      ][      ]</div></li><li><div>What if we allow new 2 byte value to be placed in memory to cross over the two boundaries: [   <span style="font-weight: bold;">[   </span>][   <span style="font-weight: bold;">]    </span>]. Hardware would need to read from first word, and read from second word. Would need to write to first &amp; to second… for that one value</div></li><li><div>Alignment means one value only fits in one ‘word’</div></li><li><div>If we have a 2 byte value, must align within a single word value: must fall w/in 2 byte address scheme (last digit of address would fall on multiple of 2: 0, 2, 4, 6, etc)  </div></li><ul><li><div>if 4 byte value, last digit of address would fall on multiple of 0, 4, 8, etc</div></li></ul><li><div>Example: </div></li><ul><li><div>flag = 1 byte, counter = 2 bytes, pi = 4 bytes</div></li><li><div>Will fit in to 8 bytes</div></li><li><div>flag starts at address 0</div></li><li><div>counter is 2 byte value, must fall on 2-byte alignment, will start at address 2</div></li><li><div>byte at address 1 is padding</div></li><li><div><img src="Lesson%202%3A%20Syntax.html.resources/Padding.png" height="341" width="600"/></div></li></ul><li><div>Padding is only problematic, initially, when allocating too much memory</div></li><ul><li><div>Ie, if counter is int32 and would have to start on 4. padding would be 3 bytes</div></li><li><div>ie, if counter was int64 and would have to start on 8. padding would be 7 bytes</div></li></ul><li><div>To solve IFF when profile tells you to, order fields from largest to smallest to reduce padding.</div></li><ul><li><div>Instead of: <img src="Lesson%202%3A%20Syntax.html.resources/6B43F556-CBE1-40C1-A254-72A60CA0B9EF.png" height="159" width="215"/></div></li><li><div>Do: <img src="Lesson%202%3A%20Syntax.html.resources/3995DBBF-0761-4611-A5BA-B70F5BF498A7.png" height="161" width="216"/></div></li></ul><li><div>Otherwise, and in default scenario, order fields as to what makes sense</div></li><li><div>Alignment for entire struct will be that of largest field</div></li></ul><li><div>‘Literal’ == anonymous struct</div></li><li><div>Implicit Conversion</div></li><ul><li><div><img src="Lesson%202%3A%20Syntax.html.resources/647127C5-D4F4-4C7C-A468-D539CFDDF2CB.png" height="191" width="214"/></div></li><li><div>types bill and alice appear identical &amp; compatible</div></li><li><div>However, compiler error: <span style="font-size: 14.6667px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(153, 0, 0); font-family: Menlo, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">cannot use a (type alice) as type bill in assignment</span></div></li><li><div><span style="color: rgb(153, 0, 0); font-family: Menlo;"><img src="Lesson%202%3A%20Syntax.html.resources/E7859FB4-9DE9-4A61-BBAE-3F8C65BE8E59.png" height="73" width="167"/></span></div></li><li><div>This would be implicit conversion, which caused tremendous pain historically, ie</div></li><ul><li><div>when b is signed and a is unsigned, we lose precision</div></li></ul></ul><li><div>(Regular) Conversion</div></li><ul><li><div><img src="Lesson%202%3A%20Syntax.html.resources/D99C2AC5-DB8E-4A95-BCC2-0D0E2BD70569.png" height="78" width="163"/></div></li><li><div>Works</div></li><li><div>Shows Intention</div></li></ul><li><div>Conversion Exception</div></li><ul><li><div><img src="Lesson%202%3A%20Syntax.html.resources/ACA9EF55-2E6F-47BD-8D9F-2E7FA6F6B83A.png" height="247" width="241"/></div></li><li><div>Works</div></li><li><div>If dealing with values of named type, no implicit conversion</div></li><li><div>If unnamed type, we know they’re compatible, conversion is allowed</div></li></ul></ul><div><br/></div><div><span style="font-weight: bold; font-size: 18px;">Pointers - Pass By Value</span></div><ul><li><div>everything in go is passed by value</div></li><li><div>Start with logical Processor P</div></li><ul><li><div>When go program starts up, is given a logical Processor P for every core on the machine (ie 1 for single threaded in Playground).</div></li><ul><li><div>A thread is a path of execution at the OS level</div></li><li><div><img width="500" height="300" src="Lesson%202%3A%20Syntax.html.resources/F034DF28-55DA-4689-929C-FFA93526EB8F.png" height="969" width="3000"/></div></li><li><div>Executor’s job is to choose thread</div></li></ul><li><div>3 areas of memory</div></li><ol><li><div>Data Segment (global vars, read only values, etc) </div></li><li><div>Stacks</div></li><ul><li><div>Data Structure that every thread is given</div></li><li><div>At OS level, stack is contiguous block of memory, and is usually MGG</div></li></ul><li><div>Heaps</div></li></ol><li><div>As goroutine executes code and starts jumping btwn functions, the stack is critical</div></li></ul><ul><li><div>When goroutine gets to main, </div></li><ul><li><div>whenever function call is made, goroutine takes <u>frame</u> of memory off the stack</div></li><li><div>goroutine only has direct access to memory for the frame it is operating on</div></li></ul></ul><li><div>Parameters are good design, but also have mechanical purpose: Get data into new frame</div></li><ul><li><div><img src="Lesson%202%3A%20Syntax.html.resources/24E839AC-154A-4163-BC2A-53E449816870.png" height="194" width="637"/></div></li><li><div><span style="font-family: Menlo, monospace; font-size: 14.6667px; color: rgb(153, 0, 0); font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">count:   Value Of[ 10 ]  Addr Of[ 0x41a78c ]</span></div></li><li><div><span style="color: rgb(153, 0, 0); font-family: Menlo, monospace; font-size: 14.6667px; orphans: 2; widows: 2;">inc:    Value Of[ 11 ]  Addr Of[ 0x41a788 ]</span><br/></div></li><li><div style="color:rgb(0, 0, 0);font-family:Menlo, monospace;font-size:14.6667px;font-variant-caps:normal;font-variant-ligatures:normal;letter-spacing:normal;orphans:2;widows:2;word-spacing:0px;"><span style="color: rgb(153, 0, 0);">count:  Value Of[ 10 ]  Addr Of[ 0x41a78c ]</span></div></li></ul><li><div>Data composed of value &amp; address</div></li><li><div>When 10 is passed into increment(), a copy of the value is made. </div></li><li><div><u>Value Semantics</u> : </div></li><ul><li><div>benefit of ideas of isolation and immutability (ie inc gets mutated only within increment())</div></li><li><div>cost: multiple copies of value across the program</div></li><li><div>ie: 2nd print from main() doesn’t have updated value</div></li><li><div>mutating here is safe</div></li></ul></ul><div><span style="font-weight: bold; font-size: 18px;">Pointers - Sharing Data</span></div><ul><li><div><font style="font-size: 14px;"><u>Pointer Semantics</u> - sharing data by address</font></div></li><ul><li><div>mutating here is less safe - must always be aware when other threads have access to the data</div></li><li><div>Fixes the efficiency issue: one data shared across multiple frames</div></li></ul><li><div>* operator allows us to declare pointer variable</div></li><li><div>pointers are literal types</div></li><li><div>take any existing type, put * in front of it, now have the literal pointer type for that</div></li><li><div>inc now represents ability to store address</div></li><li><div>pointers allow us to read / write data OUTSIDE of frame</div></li><li><div>Not enough to just store address, we want to manipulate the data (of specific type) at that address, so need to declare var’s with * and type</div></li><li><div>Stack</div></li><ul><li><div>as we make function calls, we progress DOWN</div></li><li><div>as we return, we come back UP</div></li><li><div>Memory below the active frame is invalid - cannot be accessed, is cleaned up</div></li></ul></ul><div><span style="font-weight: bold; font-size: 18px;">Pointers - Escape Analysis</span></div><ul><li><div>Cognitive Load of understanding how to manage memory</div></li><li><div>Go takes this load off of us</div></li><li><div>Factory Functions</div></li><ul><li><div>V1 uses Value semantics</div></li><ul><li><div><img src="Lesson%202%3A%20Syntax.html.resources/E604DBEC-0F7F-49F5-9DCB-441B801BCBBB.png" height="20" width="190"/></div></li></ul></ul><ul><ul><li><div><img src="Lesson%202%3A%20Syntax.html.resources/BBE7D598-C588-4E69-9FA7-85C6853F64EA.png" height="214" width="426"/></div></li><li><div><img width="900" height="450" src="Lesson%202%3A%20Syntax.html.resources/6E08EDCA-8CB4-4CD7-9B1D-A82C23231CC9.png" height="638" width="3000"/></div></li></ul></ul><li><div>&amp; means Sharing</div></li><li><div>Enter the Heap: </div></li><ul><li><div>Stacks are self-cleaning (everything below Active Frame on Stack is cleaned)</div></li><li><div>Compiler performs static code analysis, specifically here: escape analysis</div></li><ul><li><div>Does value stay on stack (ideally, yes b/c stacks are fast &amp; self-cleaning, thus no need for garbage collector)</div></li><li><div>OR: does it escape to the Heap? </div></li></ul><li><div>Go syntax abstracts away machine</div></li><li><div>Escape analysis doesn’t tell us anything</div></li><ul><li><div>Sharing tells us everything</div></li><li><div><img src="Lesson%202%3A%20Syntax.html.resources/0CE3FD96-67BD-4131-905F-B5362FABDA76.png" height="22" width="90"/> tells us that value is shared up the call stack, which tells program to allocate to Heap</div></li><li><div>u is value on Heap</div></li><li><div>underneath covers, it’s recognized that u needs to be pointer to Heap</div></li><li><div><img width="800" height="550" src="Lesson%202%3A%20Syntax.html.resources/E002B7F1-1C95-4161-88F6-6CCA29FA0DA3.png" height="2250" width="3000"/></div></li></ul></ul><li><div>How are stacks self-cleaning?</div></li></ul><ul><ul><li><div>As function calls are made, stacks below are cleaned</div></li><li><div>How are zero-values related here? </div></li></ul><li><div>Avoid “clever" things like: </div></li><ul><li><div><img src="Lesson%202%3A%20Syntax.html.resources/3D8A4E93-E36D-4B9E-B8C7-FABB99CDFBD3.png" height="87" width="325"/></div></li><ul><li><div>less readable</div></li><li><div>u is not value of type user, but now a pointer to value that we’re constructor</div></li><li><div>it uses pointer semantics during construction even though we’re creating a variable</div></li><li><div>semantics are mixed</div></li><li><div>Use value semantics during construction if we’re going to assign a variable</div></li><li><div>ONLY use pointer semantics during construction if we’re returning pointer or sending it through function call</div></li><li><div>Construction doesn’t tell you where something is in memory, only how you shared</div></li><li><div>Don’t start life of variable as pointer</div></li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold; font-size: 18px;">Interview Tidbits</span></div><div><span style="font-weight: bold; font-size: 18px;">Interview Tidbits</span></div><ul><li><div>Go isn’t going to go behind your back &amp; clean up &amp; make things efficient for you. This could be confusing: order your structs if you need to yourself. </div></li></ul><div><br/></div></body></html>